# ðŸŽ“ RelatÃ³rio de Aprendizagem: Teoria vs. PrÃ¡tica no NewsGrid

Este documento regista a aprendizagem tÃ©cnica sobre **Sistemas DistribuÃ­dos** e **Filas de Mensagens**, comparando a implementaÃ§Ã£o "padrÃ£o" (encontrada em tutoriais de RabbitMQ) com a implementaÃ§Ã£o real aplicada no projeto **NewsGrid**.

## 1. Quadro Comparativo: Do Tutorial para a ProduÃ§Ã£o

A tabela abaixo traduz os conceitos abstratos estudados para os ficheiros concretos do nosso cÃ³digo. Ã‰ o resumo de "onde estÃ¡ o quÃª".

| Conceito TeÃ³rico | No Tutorial ClÃ¡ssico (Python) | No NewsGrid | FunÃ§Ã£o PrÃ¡tica |
| :--- | :--- | :--- | :--- |
| **Producer** (Produtor) | `new_task.py` | `app/api/analyze/controller.py` | Ponto de entrada. Recebe o pedido HTTP do utilizador e publica a mensagem na fila. |
| **Queue** (Fila) | `task_queue` | `queue_research` & `queue_analysis` | Buffer que armazena as tarefas (mensagens) atÃ© que um worker esteja disponÃ­vel. |
| **Consumer** (Consumidor) | `worker.py` | `app/workers/worker_*.py` | Processo contÃ­nuo que retira mensagens da fila e executa o trabalho pesado. |
| **Payload** (A Mensagem) | String simples (`"Hello..."`) | JSON Estruturado (`{"task_id": "...", "topic": "..."}`) | Os dados que viajam entre os sistemas. Transportando o contexto da IA. |
| **Work** (O Trabalho) | `time.sleep(x)` | **Agno Agent (`agent.run()`)** | A tarefa bloqueante. SubstituÃ­mos a "espera falsa" por processamento real de IA (LLM). |
| **Ack** (ConfirmaÃ§Ã£o) | `ch.basic_ack()` | `ch.basic_ack()` | Garante que a mensagem sÃ³ sai da fila se a IA terminar o trabalho com sucesso. |

---

## 2. Aprofundamento das DiferenÃ§as

O tutorial ensina a mecÃ¢nica bÃ¡sica (o "transporte"). O NewsGrid aplica essa mecÃ¢nica para resolver um problema real de engenharia.

### A. De Script para API (O Produtor)
* **Aprendizagem:** Num tutorial, rodamos um script `python new_task.py "msg"` manualmente.
* **AplicaÃ§Ã£o:** No NewsGrid, o "gatilho" nÃ£o sou eu no terminal, Ã© o utilizador final. Por isso, embutimos o cÃ³digo do produtor dentro do **FastAPI** (`controller.py`). O `send_to_queue` Ã© a ponte entre o mundo HTTP (sÃ­ncrono) e o RabbitMQ (assÃ­ncrono).

### B. De "Sleep" para "Think" (O Trabalho)
* **Aprendizagem:** Tutoriais usam `time.sleep()` para simular trabalho pesado.
* **AplicaÃ§Ã£o:** O nosso "peso" Ã© real. A chamada `agent.run()` demora segundos (ou minutos) a ir Ã  web e consultar o LLM. Ã‰ aqui que o padrÃ£o de filas brilha: a API responde em milissegundos, mas o agente pode demorar o tempo que precisar sem travar o sistema.

### C. Pipeline vs. Tarefa Ãšnica
* **Aprendizagem:** A maioria dos exemplos mostra apenas 1 fila e 1 tipo de worker.
* **AplicaÃ§Ã£o:** ImplementÃ¡mos um padrÃ£o de **Pipeline (Cadeia)**. O output do *Researcher* torna-se automaticamente o input do *Analyst*.
    * *Fluxo:* `Fila 1` -> `Researcher` -> `Fila 2` -> `Analyst` -> `Ficheiro Final`.

---

## 3. Diagrama da Arquitetura Implementada

VisualizaÃ§Ã£o do fluxo de dados implementado no cÃ³digo:

```mermaid
graph LR

User((UsuÃ¡rio))
A[API Gateway FastAPI]
Q1([Queue: Research])
Q2([Queue: Analysis])
W1[Worker: Researcher Busca Web]
W2[Worker: Analyst SÃ­ntese LLM]
Redis[(Redis JSON Result)]

User -->|POST /analyze| A
A -->|1. Cria Task| Q1

Q1 -->|2. Consome| W1
W1 -->|3. Envia Contexto| Q2

Q2 -->|4. Consome| W2
W2 -->|5. Salva JSON| Redis

linkStyle 0,1,2,3,4,5 stroke:#333,stroke-width:1.5px;
```