# üîê Autentica√ß√£o e Seguran√ßa - NewsGrid

Este documento descreve o funcionamento do sistema de autentica√ß√£o via Sess√µes implementado no NewsGrid, utilizando Redis como fonte de verdade.

## üß† Arquitetura

O sistema utiliza uma estrat√©gia de **Sess√µes com Cookies**. Ap√≥s o login, uma sess√£o √© criada e armazenada em um cookie seguro. As rotas protegidas verificam a validade da sess√£o automaticamente.

### Fluxo de Valida√ß√£o
1. **Cliente** faz login enviando o token via POST para `/api/v1/auth/login`.
2. **API (FastAPI)** valida o token, cria uma sess√£o no Redis e define um cookie `session_id`.
3. **Para rotas protegidas:** A API verifica o cookie `session_id` via depend√™ncia `verify_session`.
4. **Redis** √© consultado na chave `session:{session_id}`.
5. **Se V√°lido:** O Redis retorna o `username` associado. A API permite o acesso e injeta o usu√°rio no contexto.
6. **Se Inv√°lido:** A API retorna `401 Unauthorized`.

---

## üöÄ Como Usar

### 1. Credenciais Iniciais (Seed)
Para inicializar o sistema com um usu√°rio administrador, execute o script de seed:

```bash
make seed
# ou
uv run python -m scripts.seed_initial
```

Isso cria o usu√°rio padr√£o no Redis se ele n√£o existir.

* **Usu√°rio Padr√£o:** `admin`
* **Token Padr√£o:** `12345678-1234-5678-9012-123456789012` (Configur√°vel via `settings.default_token` pelo `.env`)

### 2. Processo de Autentica√ß√£o
1. **Login:** Envie uma requisi√ß√£o POST para `/api/v1/auth/login` com o token no body.
2. **Uso:** O navegador/cliente mant√©m o cookie automaticamente para requisi√ß√µes subsequentes.
3. **Logout:** Envie uma requisi√ß√£o POST para `/api/v1/auth/logout` para encerrar a sess√£o.

---

## üì° Endpoints de Autentica√ß√£o

### Login

**POST** `/api/v1/auth/login`

**Body:**

```json
{
  "token": "12345678-1234-5678-9012-123456789012"
}
```

**Resposta de Sucesso:**

```json
{
  "message": "Login realizado",
  "user": "admin"
}
```

Define um cookie `session_id` que expira em 24 horas.

### Logout

**POST** `/api/v1/auth/logout`

Remove o cookie `session_id` e invalida a sess√£o no Redis.

### Renova√ß√£o e Expira√ß√£o de Sess√µes

- **Expira√ß√£o:** Sess√µes expiram automaticamente ap√≥s 24 horas de inatividade para garantir seguran√ßa.
- **Relat√≥rios:** Relat√≥rios criados durante a sess√£o permanecem associados ao usu√°rio no Redis e podem ser acessados ap√≥s um novo login. Eles n√£o s√£o afetados pela expira√ß√£o da sess√£o.
- **Renova√ß√£o:** N√£o h√° extens√£o autom√°tica de sess√µes. Para renovar o acesso, o usu√°rio deve fazer login novamente via `/api/v1/auth/login`. Isso cria uma nova sess√£o e define um novo cookie.

### Verificar Usu√°rio Atual

**GET** `/api/v1/auth/me`

Retorna o usu√°rio autenticado atual.

### Criar Novo Usu√°rio

**POST** `/api/v1/users/`
*Requer sess√£o ativa (usu√°rio logado).*

**Body:**

```json
{
  "username": "parceiro11",
  "token": "123e4567-e89b-12d3-a456-426614174000" // Opcional; se informado, deve ser UUID v√°lido (36 caracteres). Se omitido, ser√° gerado automaticamente.
}
```

### Listar Usu√°rios

**GET** `/api/v1/users/`
*Requer sess√£o ativa.*

Retorna todos os usu√°rios cadastrados no sistema.

### Revogar Acesso

**DELETE** `/api/v1/users/{username}`
*Requer sess√£o ativa.*

Remove imediatamente o acesso do usu√°rio, invalidando o token e sess√µes ativas.

---

## üõ°Ô∏è Estrutura no Redis

Para manter a organiza√ß√£o, utilizamos *Namespacing* nas chaves do Redis:

| Tipo | Padr√£o da Chave | Exemplo | Descri√ß√£o |
| --- | --- | --- | --- |
| **Token** | `auth:token:{token}` | `auth:token:abc-123` | Guarda o `username` dono do token. |
| **Usu√°rio** | `auth:user:{username}` | `auth:user:admin` | Guarda o `token` atual do usu√°rio (lookup reverso). |
| **Lista** | `auth:users_list` | `auth:users_list` | Set contendo todos os usernames ativos. |
| **Sess√£o** | `session:{session_id}` | `session:uuid-123` | Guarda o `username` associado √† sess√£o (expira em 24h). |
| **Relat√≥rios** | `user:{username}:reports` | `user:admin:reports` | Set contendo IDs dos relat√≥rios gerados pelo usu√°rio. |

---

## üîÑ Fluxo de Processamento (Worker)

1. O usu√°rio autenticado solicita uma an√°lise.
2. A API anexa o `user_id` (username) no payload da mensagem e envia para o RabbitMQ.
3. O Worker processa a IA.
4. O Worker salva o relat√≥rio final e usa o `ReportService` para vincular esse relat√≥rio √† lista do usu√°rio (`user:{username}:reports`).

Isso garante que cada usu√°rio tenha acesso apenas/historicamente aos seus pr√≥prios relat√≥rios.

---

## üìã Exemplos Pr√°ticos

### Usando cURL (Terminal)

#### 1. Fazer Login

```bash
curl -X POST "http://localhost:8000/api/v1/auth/login" \
     -H "Content-Type: application/json" \
     -d '{"token": "12345678-1234-5678-9012-123456789012"}' \
     -c cookies.txt
```

Isso salva o cookie em `cookies.txt`.

#### 2. Fazer uma Requisi√ß√£o Protegida (usando o cookie)

```bash
curl -X POST "http://localhost:8000/api/v1/analyze/?topic=Inteligencia%20Artificial" \
     -H "accept: application/json" \
     -b cookies.txt \
     -d ""
```

#### 3. Verificar Usu√°rio Logado

```bash
curl -X GET "http://localhost:8000/api/v1/auth/me" \
     -b cookies.txt
```

#### 4. Logout

```bash
curl -X POST "http://localhost:8000/api/v1/auth/logout" \
     -b cookies.txt \
     -c cookies.txt
```